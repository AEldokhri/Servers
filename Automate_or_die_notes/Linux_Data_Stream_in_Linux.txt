
طيب بالنسبة للأوامر في 3 حالات قياسية للأمر بسموها Data Stream:
- Standard Input (stdin):
و دي طرق الإدخال بالنسبة للأمر، و في العادة بكون الإدخال عن طريق الكيبور بصورة إفتراضية، و ممكن يتم الإدخال عن طريق ملف.
و يرمز له بالرمز 0

- Standard output (stdout):
و دي طرق الإخراج بالنسبة للأمر، و في العادة يكون الإخراج عن طريق الشاشة بصورة إفتراضية، و ممكن يتم الإخراج إلى ملف.
و يرمز له بالرمز 1

- Standard Error (stderr)
و دي الأخطاء حقت الأمر (و دا عنوان الليلة)، و بصورة إفتراضية يتم إخراج الأخطاء على الشاشة، و أيضا يمكن تحويل عرض الأخطاء لي ملف، و طبعا كل خطأ عنده حالة خروج.

و يرمز له بالرمز 2

تحاول تستعمل حالات الخروج (Exit Status), و طبعا هنا على حسب اللغة الإنت شغال بيها في لغات عندها حالات خروج جاهزة زي ال Bash في اللنكس عندها حالات الخروج يا صفر (و هنا معناها الأمر اتنفذ)، أي رقم تاني معناها الأمر ما اتنفذ او اتنفذ لكن بي أخطاء (و طبعا اي خطأ عنده رقم الخروج الخاص بيه).

طيب نجرب نعمل ملف عن طريق الأمر touch
~$ touch myfile.txt
~$ ls myfile.txt
myfile.txt

لو داير تعرف حالة الخطأ لي آخر أمر نفذته (Error Status)
~$ echo $?
0
~$ rm myfile.txt
~$ ls myfile.txt
ls: cannot access 'myfile.txt': No such file or directory
~$ echo $?
2
~$
و طبعا كل أمر عنده الأخطاء حقت الخروج تبعه و نحنا في مثالنا مستعملين أمر ls

 و دي رسائل الخروج تبعه و طبعا بتلقاها في امر المانوال
~$ man ls

Exit status:
   0  if OK,

   1  if minor problems (e.g., cannot access subdirectory),

   2  if serious trouble (e.g., cannot access command-line
      argument).


و لو عندك stderr عاوز تحوله لي ملف 
~$ ls myfile.txt 2> myerr.txt
 myerr.txt و كدا ما حيظهر ليك خطأ و حيكون محفوظ في الملف 


و لو عاوز الخطأ ما يظهر لي أصلا ممكن اوجه للمسار /dev/null 
~$ ls myfile.txt 2> /dev/null




 |+~~~~~~~~~~~~~~~+
 || Best regrets  |
 || Mohamed Ayman |
 || kabantsh      |
 |+~~~~~~~~~~~~~~~+
 |
 |
 |